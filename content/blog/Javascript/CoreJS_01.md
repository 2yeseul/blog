---
title: '[코어자바스크립트] 01. 데이터 타입'
date: 2022-02-03 00:00:00
description: ""
tags: [Javascript, 코어자바스크립트]
thumbnail: 
---   
# 데이터 타입의 종류
![image](https://user-images.githubusercontent.com/43533905/153742235-8ef5312f-8c0d-41b4-bcdb-3b1b86444386.png)

- 기본형은 기본적으로 불변성을 띈다.

# 변수 선언과 데이터 할당
## 변수 선언
``` javascript
var a;
```
↪️ "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다."
식별자는 데이터를 식별하는 데 사용하는 이름, 변수명이다.

|주소|...|1002|1003|1004|1005|...|
|---|---|---|---|---|---|---|
|데이터| | | 이름: a, 값: | | |

## 선언과 할당
``` javascript
var a = 'abc';
```
[변수영역]
|주소|...|1002|1003|1004|1005|...|
|---|---|---|---|---|---|---|
|데이터| | | 이름: a, 값: @5004 | | |

[데이터 영억]
|주소|...|5002|5003|5004|1005|...|
|---|---|---|---|---|---|---|
|데이터| | | | 'abc' | | |

1. 변수 영역에서 빈 공간(@1003) 확보
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장한다.
4. 변수 영역에서 a라는 식별자를 검색한다.(@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003에 대입한다.


# 기본형 데이터와 참조형 데이터
| |변수|상수|
|---|---|---|
|변수 영역 메모리 변경 가능|O|X|

불변성 여부를 구분할 때의 기준 : 데이터 영역의 메모리가 변경 가능한지의 여부 

# 불변 객체
- 불변 객체가 필요한 경우: 값으로 전달된 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 할 때

단순히 객체를 할당을 통해 복사만 할 때, 복사된 객체는 원본 객체의 프로퍼티의 주솟값을 공유하기 때문에 원본객체 프로퍼티 값이 변경되면 복사된 객체의 프로퍼티 값도 변경된다.

**따라서 대상 객체의 프로퍼티 개수에 상관 없이 모든 프로퍼티를 복사해야 한다.**

## 얕은 복사와 깊은 복사
- 얕은 복사: 바로 아래 단계의 값만 복사
- 깊은 복사: 내부의 모든 값들을 하나하나 복사

# undefined와 null
## JS 엔진이 `undefined` 를 반환하는 경우
1. 값을 대입하지 않은 변수 = 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근 시
2. 객체 내부의 존재하지 않는 프로퍼티에 접근할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

💭 사용자가 `undefined` 명시적으로 할당할 때?
➡️ 비어있다는 의미와 같지만 **하나의 값**으로 존재하므로 배열 순회 가능
💭 아무 것도 하지 않은 채 접근 -> 자바스크립트가 undefined 반환
- 인덱스(key) 자체가 존재하지 않음

> 자바스크립트 엔진이 반환하는 경우는 우리의 통제 범위를 벗어나므로 모든 undefined가 오직 이 경우에만 해당하게끔 해주어야 한다. 즉, 직접 undefined를 할당하지 않아야한다.

↪️ **비어있음**을 명시적으로 나타내고 싶을 때는 `null`을 사용한다. 

💭 어떤 객체가 null인지 여부를 판단하고 싶을 때?
> `typeof null`은 `object`이기 대문에 다른 방식으로 접근해야한다.

``` javascript
var n = null;
console.log(typeof n); // object

console.log(n == undefined); // true
console.log(n == null); // true

console.log(n === undefined); // false
console.log(n === null); // true
```
동등 연산자(==)로 비교할 경우 null과 undefined가 서로 같다고 판단한다. 따라서 일치 연산자(===)를 써야한다.


